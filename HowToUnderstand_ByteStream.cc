/*

这里说下如何理解字节流

为什么说UDP是面向整个数据报的？

操作系统不会对UDP消息拆分，组装好整个UDP头部就交给下层网络层处理，每次发送的都是一条完整消息
每个消息都是一个边界
操作系统收到UDP报文后，会将其插入队列中，队列里的每个元素就是一个UDP报文，每次调用recvfrom()系统调用读数据的时候，就从队列里取出一条数据
然后从内核拷贝给用户缓冲区
队列：skb

为什么说TCP是面向字节流的？
每次发出去的TCP消息可能会被操作系统分成多条TCP报文
这样接收方就不知道到底是不是完整消息了，每次发送多取决于流量控制，拥塞控制等
所以每次需要我们自己去处理整个字节流

如何解决粘包？
固定长度，每次读指定 比如64字节 但实际用的少

特殊字符作为边界 尾巴插入特殊字符串，读到就认为这是一条完整消息 比如HTTP的规则就是

自定义消息结构 发送结构体，读取里面的长度字段，拿到有效载荷数据

*/