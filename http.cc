/*

HTTP :  HTTP基本概念:   HTTP是什么？ HTTP常见的状态码有哪些？HTTP常见字段？
        GET与POST:      GET和POST有什么区别？ GET和POST方法都是安全和幂等的吗？
        HTTP特性:       HTTP1.1优点？缺点？性能？
        HTTP缓存技术:   哪些缓存方式？强制缓存？协商缓存？
        HTTP与HTTPS:    区别？解决了HTTP的哪些问题？HTTPS如何建立连接？
        HTTP的演变:     HTTP1.1比1.0提高了哪些性能？HTTP2/3都做了哪些？

*/

/*

《HTTP基本概念》
                    HTTP是什么？
-- 超文本传输协议 协议本质上是一种约定，客户端跟服务端都采纳 请求和应答双方一致的协议

                    HTTP常见的状态码有哪些？
--HTTP状态码一般是表示收到响应时候 对应的状态的 
-- 1XX 一般代表 临时响应，客户端需要等待最终响应，比如大文件传输前的确认
    【100】：继续 服务器已经收到请求头，可以继续发送请求体。
            一般客户端发送带有expect:100-continue请求头的POST/PUT请求时用
            避免请求体过大然后发送过去，但是服务器拒绝接收浪费带宽
            有些网站不支持expect 这个报头，像百度直接返回400错误了，有的网站支持（我用自己写的c++程序和Postman测试的)
    【101】：协议切换，从http到websocket
             有些常见 例如实时股票 实时聊天 需要双向通信，可以切换到websocket协议进行 只能http1.1->2 http->websocket 不能反向切换
             客户端发送一个报头如upgrade:websocket后，服务端返回101代表切换协议成功
    【102】：处理中 服务器已经收到请求并且正在处理，但是处理时间较长，告知客户端请求未丢失，正在处理
             异步场景用，异步处理长任务，避免客户端超时重试
    【103】：提前提示 服务器在返回最终响应前，提前发送关键响应头 让客户端提前加载静态资源 优化页面加载速度
            典型示例：
            客户端请求GET /home HTTP/1.1；
            服务器需要 1 秒生成首页动态内容（如用户个性化推荐），同时返回 103 + Link: </css/home.css>; rel=preload, </js/home.js>; rel=preload；
            客户端收到 103 后，立即开始下载home.css和home.js；
            1 秒后服务器返回 200 + 首页 HTML，此时客户端已加载完静态资源，可快速渲染页面。
            补充说明：需客户端（如 Chrome、Firefox）和服务器（如 Nginx 1.13+、Apache 2.4+）均支持，属于 HTTP/2 的优化特性。
-- 2XX 一般代表 请求被服务器已经正常处理并且返回了 此时页面正常加载，数据返回
    【200】：OK 请求成功，服务器返回请求资源 200是通用的成功码，还有其他细分的
    【201】：已创建，比如新用户 新订单
    【202】：已接受，已接受到请求，尚未完成处理（异步任务）
    【204】：无内容，请求成功，但是服务器无需返回响应体（删除资源，更新资源无需返回数据） 比如DELETE PUT方法
    【206】：部分内容，服务器仅返回了部分内容，用于断点续传，多线程下载
-- 3XX 一般代表 重定向响应（需要客户端进一步操作）
    【301】：永久重定向 客户端后续请求直接访问新URL 比如域名更改 资源路径永久调整 客户端会缓存，下次请求新地址 可以手动清除缓存或设置报头nocache
    【302】：临时重定向 下次继续 不缓存
    【304】：协商缓存用，代表缓存未过期 继续使用，服务器无需返回资源体
-- 4XX 一般代表 客户端错误
    【400】错误请求，语法错误
    【401】未授权，需要登录 token过期无效
    【403】禁止访问 黑名单 没权限
    【404】未找到资源
    【405】请求方法不允许 不支持
    【406】服务器无法返回客户端可以接受的格式 编码
    【408】请求超时
    【410】资源已经删除 不恢复
    【413】请求体过大
    【414】URL过长
    【429】请求过于频繁
-- 5XX 一般代表服务端错误
    【500】服务器错误
    【502】网关错误
    【503】服务不可用，卡住了
    【504】网关超时
    【511】需要网络认证比如 wifi登录

                    HTTP常见字段？
请求：
Host ：www.qq.com 指明服务器的域名，可能多个域名对应一个ip
Accept：可接受返回类型
Accept-Encoding: gzip, deflate
User-Agent
cookie
响应：
Content-Length ： 返回数据长度
Connection ：长连接还是短连接 keep-alive/close 长连接就是保持tcp连接 http1.1默认长连接 为了兼容老版本 可以指明一下connection keep-alive
            http的长连接和tcp的长连接是两回事
Content-Type 响应格式类型 还有字符编码
Content-Encoding 数据返回的压缩方法 gzip
setcookie
cache-control

                    http的长连接和tcp的长连接
http的keep-alive是应用层 用户态实现的
tcp的keep-alive是TCP层 内核态实现的 是TCP保活机制

http短链接 每次都要tcp握手挥手 建立连接 断开连接

http1.0默认 connection不是keep-alive 的需要手动设置 长连接可以一个tcp连接服用多次请求和响应
http1.1就是默认长连接，但是可能存在队头阻塞的问题，连续发送两个请求，第一个请求得不到响应，第二个请求就无法处理
http的keep-alive是长连接，如果想要关闭的话 可以程序员手动控制，也可能系统被动触发
程序员可以在请求或者响应的时候添加connection:close就会主动关闭tcp连接 变为短连接了
还有一种被动触发就是tcp层 断开连接了 直接close掉文件描述符 强制断开
还有一种就是http1.1 可以通过报头字段设置存活规则 keep-alive:timeout=60,max=100 最大空闲时间60s 最多复用100次请求
在真实的开发场景中，优先使用keep-alive报头字段来管理连接断开 99% 的情况只需通过框架配置 Keep-Alive 超时和最大请求数
让协议和框架自动管理连接生命周期；仅在极特殊的业务场景（如支付、登录后），才通过 Connection: close 手动断开当前连接，完全不需要写定时器。

tcp的keep-alive主要负责tcp保活机制，定时发送探测包，看看对方状态是否正常，不正常就断开连接，如果对方主机不是崩溃（崩溃的话操作系统自动挥手断开）
如果对方主机是卡住了，就定时探测，发现一直得不到响应就断开连接，主要负责看看对方是否正常，而不是对方是否发送数据 内核负责的

                    http的强缓存/协商缓存
强缓存 浏览器的缓存没有过期就直接使用，不发生真实请求
返回的是200状态码，描述是from disk cache 也就是使用的强缓存
强缓存利用的是响应报头字段的Cache-Control 和 Expires 两个时间 这里面设置了Cache-Control缓存过期时间
如果强缓存过期，就开始进行协商缓存
协商缓存响应状态码304


*/