/*
TPC的特性：重传、流量控制、拥塞控制、滑动窗口

重传：超时重传  快重传  SACK  D-SACK
滑动窗口：发送窗口 接收窗口
流量控制：
拥塞控制：慢启动 拥塞避免 拥塞发生 拥塞回复


重传+++++++
底层支持：16位滑动窗口、32位序列号、32位确认序列号
】】超时重传：自己的数据包丢失、对方的确认应答丢失
】】】一种是自己的包真的丢失了，一种是对方收到了但是对方给的应答丢失了(也就认为自己的包丢了)
】】】超时时间一般就是RTO 如果RTO过大，重发慢，延迟高，效率低
】】】如果RTOI过小，频繁重发，增加带宽压力，加剧网络阻塞，引起更多超时重传
】】】RTT是包的往返时间，从发送到接收确认的差值，RTO是超时重传时间
】】】合理的情况应该是RTO的值略大于RTT
】】】如果第一次重传失败了，第二次就会第一次的两倍超时重传时间
】】】超时重传问题就是太慢，周期长
】】快重传：不看时间，看报文
】】】如果说对方收到的序号不对，比如希望收到4，收到了5，此时就认为4丢包了，就发送三次相同的ACK来触发快重传
】】】快重传就是当收到三个相同的ACK包时，触发，认为丢包了 重传开始 通过seq序号来作为底层支持
】】】但是快重传还有一个问题，就是比如发送了1-6的序号包，此时2和3丢失了，但是返回的三次ACK是2，所以下次重传2，但是3号还需要三次
】】】ACK来触发，如果重传全部1-6又浪费资源，所以有了SACK
】】SACK：选择性确认
】】】在TCP报头里的选项字段加入SACK，可以将已收到的数据的信息发送给发送方，这样发送方就知道哪些收到了，哪些没收到，选择性重传给对面
】】】Linux内核2.4后默认是打开这个功能的，也可以通过修改内核参数tcp_sack来打开这个功能
】】D-SACK：使用SACK告诉发送方有哪些数据被重复接收了
】】】这样的话对方就知道有些包不是真的丢了，而是应答丢了，你又重传发给我，我这里就有两份了
】】】Linux内核2.4后也是默认打开这个功能的，可以通过修改内核参数tcp_dsack来打开这个功能


滑动窗口+++++++
如果每次发送一次数据就进行一次应答，你一句我一句，效率就不高了 上次的话往返时间太长，影响下次的对话小v了
所以可以批量发送，底层支持就是窗口的概念
窗口就是操作系统开辟的一段缓冲区空间，发送方在等到上次发送的数据的确认应答的时候，必须在窗口内保留之前的就报文
如果正常收到应答就可以清除了

】】窗口的大小通常由接收方的窗口大小决定，发送方不能超过，不然无法正常接收
发送方的窗口： 
|| 已发送并收到ACK确认的数据 || 已发送但未收到ACK确认的数据 || 未发送但大小在接收方处理范围内的数据 || 未发送但总大小超过对方的接收处理范围 ||
当发送方把数据全部发送，此时可用窗口大小就变0了，没法继续发送数据了

发送窗口大小取决于接收方 发送窗口=已发送但未收到ACK确认的数据 + 未发送但总大小未超过接收方处理范围的数据

接收方窗口：
|| 已成功接收并确认的数据 || 未收到数据但可以接收的数据 || 未收到数据但不可以接收的数据 ||

发送和接收窗口不一定完全相等，只是约等于 因为双方也需要通过网络通信交换窗口大小 存在延迟




流量控制+++++++++
发送方不能无脑的发送数据，要考虑接收方能力
采用了流量控制：
TODO.....

还有Nagle算法 ，等窗口大小》=MSS 并且数据大小》=MSS或者收到之前发送数据的ACK回应包时才发送窗口内的数据
有时候为了3个字节的数据，比如对方接收能力就三个字节，然后报头20字节就为了传输这个3个字节，浪费带宽所以启用了Nagle算法
增加了延迟，但是降低了带宽 默认是打开的，但是telnet和ssh这种交互性强的关闭了，怕延迟
我们可以在代码通过TCP_NODELAY选项关闭这个算法



拥塞控制+++++++++++
流量控制是没有牵扯网络延迟的情况下，只是主机的处理能力问题
网络还有延迟的，单纯的流量控制，如果发送大量数据，也可能因为网络延迟大面积丢包，虽然可以重传但是浪费带宽
所以有了拥塞控制，也就有了拥塞窗口

拥塞窗口cwnd是发送方维护的一个状态变量，根据网络状况动态变化

网络没有拥塞就增大cwnd
出现拥塞就减少cwnd
判断拥塞就是看有没有触发超时重传，有就减少cwnd

cwnd单位是MSS 最大段尺寸

拥塞控制的4个算法：慢启动、拥塞避免、拥塞发生、快速回复
慢启动：每次收到一个ACK，cwnd+1  

指数增长

当超过阈值ssthresh状态变量就使用拥塞避免算法
拥塞避免算法：每收到一个ACK，cwnd+ 1/cwnd 变成了线性增长

拥塞发生：
超时重传：阈值改成cwnd/2 cwnd初始化为1（通过ss -nli | grep cwnd可以查看)
这种太慢了，于是有了快重传
快重传：cwnd=cwnd/2 不直接变1 阈值改为cwnd 进入快速恢复算法

快速恢复算法：
收到三个重复的ACK也就是快重传了，就这样，不会减低太多cwnd，最大化拉满带宽

*/