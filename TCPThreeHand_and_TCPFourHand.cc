/*

TCP Transmission Control Protocol 传输控制协议
有连接、面向字节流、可靠


TCP报头
| 源端口号 | 目的端口号 |
| 32位序号 | 32位确认序号 |
| 16位校验和 | 16位滑动窗口 |
| 16位紧急指针 |
| 4位首部长度(报头总长度,单位4字节 15*4=60字节 报头最大60字节) |
| 6个标志控制位(SYN\ACK\FIN\RST\PSH\URG) |
| 6个保留位(暂时没用) |
| 选项(20字节) |


报头最大20-60字节，剩下的就是有效载荷数据


序号：建立连接时由计算机生成的随机数作为初始值，通过SYN包发给接收端主机，每发送一次数据就累加一次该数，解决网络包乱序的问题
确认序号：下一次期望收到的数据包的序列包，发送端收到这个确认序号，就认为这个序号之前的数据都已经正常接收到了，这次是想要从这次号开始
6个控制标志位 ACK(除了最初连接的SYN包 都为1 确认应答) RST(1表示异常，必须强制断开连接) SYN(1表示希望建立连接) 
             FIN(1表示后面没数据了，希望断开连接) URG(通知有紧急数据) PSH(通知赶快拿走缓冲区数据)


为什么需要TCP协议呢?
TCP工作在传输层，网络层是ip负责的，网络层不可靠，不保证网络包的完整性，只负责路由寻址


字节流是因为一条完整的消息可以被操作系统分成多个TCP报文发送，需要字节找出边界 拿到完整消息


TCP依靠四元组标识一条TCP连接
源端口 目的端口 源ip地址 目的ip地址


一个服务端监听了一个端口，他的TCP最大连接数能是多少？
理论上很大，无上限，ipv4来说 2的32次方个地址*2的16次方 也就是全球主机数量再乘以每台主机的端口数 2的48次方
但是受到一些限制，比如主机硬件配置，文件描述符限制，内存等等 内存满了会触发OOM


UDP和TCP有什么区别
UDP不提供复杂的控制机制，利用IP提供无连接的通信服务
UDP报头很简单 报头固定8字节（64位）
| 源端口16位 | 目的端口16位 |
| 整包长度16位 | 校验和16位 | 
一共64位
UDP报文最多64KB 2的16次方 但是可能收到MTU影响 1500 1460等
TCP面向连接、可靠、字节流
具有流量控制，超时重传，拥塞控制特性
UDP分片是在IP层分片 TCP分片是在本层传输层就分片了，目的是减少分片，尽可能自己解决 不用分片机制
TCP:HTTP/HTTPS FTP TELNET
UDP:DNS 游戏 视频 直播 等


TCP有效数据长度 = IP总报文长度-IP报头长度-TCP报头长度
为什么UDP需要一个包长度字段，这样计算不也可以吗？
说法一：历史遗留问题 
说法二：凑齐整数倍 4的倍数 8字节，否则就是6字节了


UDP和TCP可以使用同一个端口吗？
可以的
IP网络层在拿到数据包后，需要交付给上层，此时就会根据包中的标识来决定给UDP还是TCP模块
这两个模块是单独分开的，所以虽然同样的端口，但是模块不同，UDP的9999端口和TCP的9999端口 不一样
本身端口是为了区分哪个程序的，两个不同的模块也可以做到区分


MAC负责局域网找主机，IP负责跨网络找主机，TCP/UDP负责端口寻找应用


TCP的三次握手++++++++++++
因为TCP面向连接，所以必须三次握手建立连接

客户端              SYN(附带一个随机序列号值(报头里的序列号字段))---》   服务端
客户端发完进入SYN_SENT状态                       服务端收到后进入SYN_RECV状态（进入半连接队列）
                                               （如果半连接队列满了或者强制启用了syncookie就不进入半连接队列，
                                                生成一个值加到SYN+ACK包中给客户端）

客户端             《--SYN+ACK(服务端也把自己的随机序列号值加进去，把收到的客户端的序列号值+1放确认序号字段)    服务端
客户端收到后进入ESTABLISH状态                  

客户端              ACK--》(第三次也就是这次可以附带数据了)     服务端
                                                  服务端收到后进入ESTABLISH状态

前两次握手是没有携带数据的，第三次握手就可以携带数据了 


为什么是三次而不是两次、四次呢？
三次保证双方具备接收 发送能力 全双工
两次太少，可能遭到攻击，服务端第二次就要建立连接，客户端恶意SYN攻击 资源殆尽
四次太多 因为有捎带应答机制，可以请求同时应答

还有就是两次握手无法解决过期连接请求 如果客户端发SYN 服务端回ACK 然后两者建立连接
如果客户端第一次SYN因为网络延迟没有送过去，然后重传第二次 成功建立连接了
此时第一次的SYN网络延迟好了，然后服务端以为又是新连接 又建立了连接 此时浪费服务端资源
攻击者就通过这种方式不断SYN洪水攻击
通过三次的方式让客户端也回应ACK确保确实需要建立连接
客户端通过序列号 然后看服务端发来的序列号确保是不是自己的连接，不是就RST断开，防止新旧连接干扰 因为每次的第一次SYN+序列号都是随机生成的
两次的情况下，没有中间的验证步骤 服务端每次都以为是新连接 每次都要建立连接


还有就是实现序列号的同步
第一次 客户端把自己的序列号发给对方
第二次 服务端把自己的序列号发给对方
第三次 客户端确保收到了服务端的序列号 因为确认应答号

总结来说就是 1.全双工 保证序列号同步且收到 为了可靠性准备 2.安全，防止新旧连接干扰+SYN攻击，资源浪费耗尽 3，四次多余有捎带应答机制


这也就是为什么每次的SYN产生的序列号ISN都不一样，防止历史报文干扰 防止黑客伪造相同的序列号


这个ISN序列号怎么产生的呢? 随机产生，通过时钟 有一个随机生成算法


既然IP层分片，你TCP为什么还要搞一个MSS最大段尺寸
MTU:最大传输单元 1500
MSS:最大段尺寸  1500-20IP报头-20-60TCP报头 = 1460
因为如果让IP层来分片，一个分片丢失，整个报文所有分片都要重传
IP层会分片然后组装完成才交付给上层传输层，需要等待完整报文才能给传输层 延迟高了就
而且IP层没有超时重传机制 ，导致只能TCP接收不到对方消息，触发超时重传 而且重传的是整个报文
所以让IP层分片效率是很低的
所以让TCP层提前进行分片 也不能叫做分片把 只是防止IP层分片，自己先切分开来
这样超发也是以MSS为单元，不浪费带宽，不用重传整个报文
IP层如果组装失败，只能全部重传，因为组装失败 丢失了
UDP的IP分片问题更严重，分片丢了需要重传整个报文，恰好UDP没有重传功能，就很离谱。。。。所以UDP不适合传输大文件


第一次握手丢失会怎样？
第一次也就是客户端发给服务端的SYN丢了，丢了服务端无感知，客户端没收到ACK+SYN 然后就重传SYN 一直收不到就断开了 不发送了
第二次握手丢失会怎样？
第二次也就是服务端发给客户端的SYN+ACK丢了，客户端收不到ACK+SYN 还是跟第一次握手丢失情况一样，以为服务端没收到，继续重发SYN
        服务端收不到客户端 也会触发重传 
        第二次握手丢失 客户端跟服务端都会重传 SYN重传次数由tcp_syn_retries参数决定，SYN+ACK由tcp_synack_retries参数决定
第三次握手丢失会怎样?
第三次也就是客户端发给服务端的最后ACK丢失了，因为客户端发送完最后ACK已经进入ESTABLISH状态了
        服务端收不到ACK 服务端是没有进入ESTABLISH状态的，由于ACK是不会重传的，所以如果服务端收不到最后ACK，就会触发超时重传，
        服务端重新发送SYN+ACK,客户端重新发送ACK
        如果服务端重传一直得不到响应，服务端就断开连接了
        此时客户端还以为ESTABLISH的，然后发送消息给服务端，服务端会回应RST通知对方断开连接 服务端会查表四元组连接表发现没有这个连接
        客户端收到RST就直接从ESTABLISH变成CLOSE状态了，RST不走四次挥手流程 是强制断开 而且这次发送数据全部丢弃 丢失



        TCP四次挥手++++++++++++

客户端发送FIN给服务端 客户端进入FIN_WAIT1状态 服务端收到后进入CLOSE_WAIT状态
服务端发送ACK给客户端 客户端收到后进入FIN_WAIT2状态 
服务端主动发送FIN给客户端 服务端从CLOSE_WAIT状态变成LAST_ACK状态 等待客户端响应
客户端发送ACK给服务端 客户端进入TIME_WAIT状态

主动断开的一方陷入TIME_WAIT状态，为了确保对方收到最后一个ACK 两者都正常进入CLOSE状态，否则可能被动关闭一方无法正常关闭

为什么是2MSL 一次是报文最大生存周期 一问一答就是2MSL

需要TIME_WAIT是因为 1.防止历史连接的报文干扰（网络中之前阻塞了现在突然发送过来，因为TCP是四元组，以为是同一个连接）
                    2. 保证被动方正常关闭 如果没用time_wait 假设最后ACK丢失，被动方重传FIN，此时客户端已关闭 就发送RST给对方
                        RST不是一种优雅的关闭方式 是一种错误算是，不优雅 
            
如果TIME_WAIT过多 1.系统资源浪费 文件描述符 系统资源 CPU 内存 线程 2.占用端口资源，端口一般几万个 没了就没了 当然也可以通过修改
                    内核参数来设置

一般高并发客户端可能导致端口资源浪费
服务端一般只监听一个端口，所以只浪费这一个端口 在TIME_WAIT状态时


高并发客户端优化TIME_WAIT 修改内核参数 此时重新connect就寻找一个TIME_WAIT超过1秒的复用给他使用
还有一种方式 设置TIME_WAIT值小一些
还可以使用setsocket选项 调用close后触发RST 不走四次挥手流程 也就没有TIME_WAIT状态了

TIME_WAIT是朋友，帮助我们的，尽可能不要去除
服务端尽可能永远不要主动断开连接，让客户端去断开，去承受TIME_WAIT


服务器出现大量TIME_WAIT 原因：
1.HTTP是短连接
2.HTTP长连接超时（定时器到了 主动断开连接  请求数量上限


服务端出现大量CLOSE_WAIT状态的原因：
1.代码问题，没有正常close 
2.代码问题，没有accept接收上来，导致没有办法close掉


如果连接建立了，客户端突然故障 会怎样？
断电突发情况的话，TCP有保活keep-alive机制或者服务端代码层面的心跳机制，发现一直得不到响应就断开连接了
如果是崩溃，一般操作系统会代替FIN四次挥手 
如果客户端恢复了，心跳机制重新发送，但是发现连接信息不对 就触发RST发给客户端 重置连接


RST是强制重置 断开连接 不是重新连接


没有accept也可以建立起连接，内核帮我们做的，我们只需要accept捞上来文件描述符即可

全连接队列和半连接队列实际上不同
半连接队列是个哈希表，全连接队列是个链表

全连接队列是链表是因为已经建立了连接，等待被accept应用拿走，拿走的时候不关注拿走谁，只要是个连接就行了
所以可以用链表
但是半连接队列不同，都是不完整的连接，需要等待第三次握手的到来 识别出是哪个连接，通过哈希表快速查找，如果是链表就需要依次遍历了，慢

全连接队列满了，丢弃第三次握手的ACK，或者设置内核参数，为了额外RST通知对方，而不是让对方一直重传ACK

半连接队列满了，一般就是SYN攻击 新连接会拒绝，设置syncookie来直接建立连接 或者丢弃
这个syncookie并不是一个队列，因为如果他是队列，最终也会被打满，他是一个值，保存在TCP报头的序号中，以此双方进行验证，跳过半连接直接建立连接

为什么不直接采用syncookie，而是选择半连接
cookie需要解码，如果对方攻击大量SYN   +ACK包，服务端收到还需要解码，浪费CPU资源 这种叫ACK攻击  第三次握手的攻击


没有listen也可以建立起来连接（本地环回的时候才行也就是进程connect进程自己）
没有listen就没有全连接队列和半连接队列，在执行listen方法时，内核才自动创建这两个队列
但是内核还有一个全局hash表，存放sock连接的信息，客户端通过connect可以连接成功并且记录到hash表中把这个连接

如果只执行 socket() + bind()，内核收到客户端发送的 SYN 报文时，
会发现该端口对应的端点未处于 LISTEN 状态，直接返回 RST 报文（连接重置），客户端连接请求被拒绝，三次握手无法启动



字节面试题：只socket+bind 没有listen 客户端发送connect会怎样？
客户端发送SYN，服务端回复RST报文通知中止连接
内核源码中：拿到一个TCP报文后，去查找监听套接字哈希表，也就是客户端连接connect不是需要sockfd吗，就是查找这个
如果服务端没有查找到，因为没有listen也就没有监听套接字了，然后如果这个报文和校验和都没问题，就返回RST报文
也就是内核调用tcp_v4_send_rset这个函数发送RST中止这个连接


没有listen可以连接成功 仅限于自连接，客户端自己连接自己，直接通过哈希表拿到连接，不用通过两个队列了
*/